#!/usr/bin/env python3.6

import argparse
import subprocess
import sys
import zipfile
from pathlib import Path

import yaml
import pandas as pd
import tqdm

from knock_knock import experiment, table, target_info

def check_blastn():
    no_blastn = False

    try:
        output = subprocess.check_output(['blastn', '-version'])
        if b'2.7.1' not in output:
            no_blastn = True
    except:
        no_blastn = True

    if no_blastn:
        print('blastn 2.7.1 is required and couldn\'t be found')
        sys.exit(0)

def check_parallel():
    no_parallel = False

    try:
        output = subprocess.check_output(['parallel', '--version'])
        if not output.startswith(b'GNU parallel'):
            no_parallel = True
    except:
        no_parallel = True

    if no_parallel:
        print('GNU parallel is required and couldn\'t be found')
        sys.exit(0)

def parallel(args):
    check_parallel()

    if args.group:
        args.conditions['group'] = args.group

    exps = experiment.get_all_experiments(args.project_directory, args.conditions)

    if len(exps) == 0:
        print('No experiments satify conditions:')
        print(args.conditions)
        sys.exit(0)

    parallel_command = [
        'parallel',
        '--will-cite',
        '-n', '3', 
        '--bar',
        '--max-procs', str(args.max_procs),
        'knock_knock',
        'process',
        str(args.project_directory),
        ':::',
    ]

    arg_tuples = [(exp.group, exp.name, '0') for exp in exps]
    for t in sorted(arg_tuples):
        parallel_command.extend(t)

    subprocess.check_call(parallel_command)

def process(args):
    check_blastn()

    data_dir = Path(args.project_directory) / 'data' / args.group
    sample_sheet_fn = data_dir / 'sample_sheet.yaml'
    sample_sheet = yaml.safe_load(sample_sheet_fn.read_text())

    if args.sample in sample_sheet:
        description = sample_sheet[args.sample]

        if description.get('platform') == 'pacbio':
            exp_class = experiment.PacbioExperiment
        elif description.get('platform') == 'illumina':
            exp_class = experiment.IlluminaExperiment
        else:
            raise ValueError(description)
    else:
        raise ValueError(args.sample)

    exp = exp_class(args.project_directory, args.group, args.sample, description, args.progress)

    exp.process(args.stage)

def make_tables(args):
    if args.group:
        args.conditions['group'] = args.group

    fns_to_zip = []

    results_dir = args.project_directory / 'results'

    html_fn = (results_dir / args.file_name_prefix).with_suffix('.html')
    table.generate_html(args.project_directory, html_fn, args.conditions, show_subcategories=False)
    fns_to_zip.append(html_fn)

    html_fn = (results_dir / f'{args.file_name_prefix}_with_subcategories').with_suffix('.html')
    table.generate_html(args.project_directory, html_fn, args.conditions, show_subcategories=True)
    fns_to_zip.append(html_fn)

    csv_fn = (results_dir / args.file_name_prefix).with_suffix('.csv')
    df = table.load_counts(args.project_directory, args.conditions)
    df.to_csv(csv_fn)

    exps = experiment.get_all_experiments(args.project_directory, args.conditions)

    exps_missing_files = set()

    for exp in exps:
        def add_fn(fn):
            if not fn.exists():
                exps_missing_files.add((exp.group, exp.name))
            else:
                fns_to_zip.append(fn)
        
        def add_dir(dn):
            if not dn.exists():
                exps_missing_files.add((exp.group, exp.name))
            else:
                for fn in dn.iterdir():
                    add_fn(fn)

        add_fn(exp.fns['outcome_browser'])

        for outcome in exp.outcomes:
            outcome_fns = exp.outcome_fns(outcome)
            add_fn(outcome_fns['diagrams_html'])
            add_fn(outcome_fns['first_example'])
            add_dir(outcome_fns['length_ranges_dir'])

        categories = set(c for c, s in exp.outcomes)
        for category in categories:
            outcome_fns = exp.outcome_fns(category)
            add_fn(outcome_fns['diagrams_html'])
            add_fn(outcome_fns['first_example'])

    if exps_missing_files:
        print(f'Warning: {len(exps_missing_files)} experiment(s) are missing output files:')
        for group, exp_name in sorted(exps_missing_files):
            print(f'\t{group} {exp_name}')

    zip_fn = (results_dir / args.file_name_prefix).with_suffix('.zip')
    description = 'Zipping table files'
    with zipfile.ZipFile(zip_fn, mode='w', compression=zipfile.ZIP_DEFLATED) as zip_fh:
        for fn in tqdm.tqdm(fns_to_zip, desc=description):
            zip_fh.write(fn, arcname=fn.relative_to(results_dir))

    pms_fn = (results_dir / f'{args.file_name_prefix}_performance_metrics').with_suffix('.csv')
    pms = table.calculate_performance_metrics(args.project_directory, args.conditions)
    pms.to_csv(pms_fn)

def build_targets(args):
    target_info.build_target_infos_from_csv(args.project_directory, args.genome)

def build_indices(args):
    target_info.download_and_build_hg38(args.project_directory, args.num_threads)

parser = argparse.ArgumentParser()

subparsers = parser.add_subparsers(dest='subcommand', title='subcommands')
subparsers.required = True

parser_process = subparsers.add_parser('process', help='process a single sample')
parser_process.add_argument('project_directory', type=Path, help='the base directory to store input data, reference annotations, and analysis output for a project')
parser_process.add_argument('group', help='group name')
parser_process.add_argument('sample', help='sample name')
parser_process.add_argument('stage', type=int, choices=[0, 1], help='stage of processing to carry out')
parser_process.add_argument('--progress', const=tqdm.tqdm, action='store_const', help='show progress bars')
parser_process.set_defaults(func=process)

parser_parallel = subparsers.add_parser('parallel', help='process multiple samples in parallel')
parser_parallel.add_argument('project_directory', type=Path, help='the base directory to store input data, reference annotations, and analysis output for a project')
parser_parallel.add_argument('max_procs', type=int, help='maximum number of samples to process at once')
parser_parallel.add_argument('--group', help='if specified, the single group name to process; if not specified, all groups will be processed')
parser_parallel.add_argument('--conditions', type=yaml.safe_load, default={}, help='if specified, conditions that samples must satisfy to be processed, given as yaml; if not specified, all samples will be processed')
parser_parallel.set_defaults(func=parallel)

parser_table = subparsers.add_parser('table', help='generate tables of outcome frequencies')
parser_table.add_argument('project_directory', type=Path, help='the base directory to store input data, reference annotations, and analysis output for a project')
parser_table.add_argument('file_name_prefix', help='prefix for table file names')
parser_table.add_argument('--group', help='if specified, the single group name to include; if not specified, all groups will be included')
parser_table.add_argument('--conditions', type=yaml.safe_load, default={}, help='if specified, conditions that samples must satisfy to be processed, given as yaml; if not specified, all samples will be processed')
parser_table.set_defaults(func=make_tables)

parser_targets = subparsers.add_parser('build_targets', help='build annotations of target locii')
parser_targets.add_argument('project_directory', type=Path, help='the base directory to store input data, reference annotations, and analysis output for a project')
parser_targets.add_argument('--genome', default='hg19', help='name of genome to search for targets')
parser_targets.set_defaults(func=build_targets)

parser_indices = subparsers.add_parser('build_indices', help='download hg38 and build alignment indices')
parser_indices.add_argument('project_directory', type=Path, help='the base directory to store input data, reference annotations, and analysis output for a project')
parser_indices.add_argument('--num_threads', type=int, default=8, help='number of threads to use for index building')
parser_indices.set_defaults(func=build_indices)

args = parser.parse_args()
args.func(args)
